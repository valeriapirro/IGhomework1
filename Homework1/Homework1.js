"use strict";

var shadedPoly = function() {

var ncube;

var canvas;
var gl;

var texSize = 256;
var numPositions = 162;

var eye;

var aspect;
var  fovy = 90; 

var near = 0.1;//1;
var far = 3;//2.5;
var radius = 1.5;
var theta2 = 0.0;
var phi = 0.0;
var dr = 5.0 * Math.PI/180.0;

var nMatrix, nMatrixLoc;

var pointsCYL = [];
var normalsCYL = [];
var texCoordCYL = [];
var ncylinder;


// Bump Data generated by a random function which generates values between 0 and 1.
var data = new Array()
    for (var i = 0; i<= texSize; i++)  data[i] = new Array();
    for (var i = 0; i<= texSize; i++) for (var j=0; j<=texSize; j++)
        data[i][j] = Math.random();


// Bump Map Normals
var normalst = new Array()
    for (var i=0; i<texSize; i++)  normalst[i] = new Array();
    for (var i=0; i<texSize; i++) for ( var j = 0; j < texSize; j++)
        normalst[i][j] = new Array();
    for (var i=0; i<texSize; i++) for ( var j = 0; j < texSize; j++) {
        normalst[i][j][0] = data[i][j]-data[i+1][j];
        normalst[i][j][1] = data[i][j]-data[i][j+1];
        normalst[i][j][2] = 1;
    }

// Scaling to our Texture Coordinates
    for (var i=0; i<texSize; i++) for (var j=0; j<texSize; j++) {
       var d = 0;
       for(k=0;k<3;k++) d+=normalst[i][j][k]*normalst[i][j][k];
       d = Math.sqrt(d);
       for(k=0;k<3;k++) normalst[i][j][k]= 0.5*normalst[i][j][k]/d + 0.5;
    }

// Normal Texture Array
var normals = new Uint8Array(3*texSize*texSize);
    for (var i = 0; i < texSize; i++)
        for (var j = 0; j < texSize; j++)
           for(var k =0; k<3; k++)
                normals[3*texSize*i+3*j+k] = 255*normalst[i][j][k];

// ---------------------------------------------CYLINDER UTILITIES-------------------------------------------------
function cylinder(numSlices, numStacks, caps) {

   var slices = 36;
   if(numSlices) slices = numSlices;
   var stacks = 1;
   if(numStacks) stacks = numStacks;
   var capsFlag = true;
   if(caps==false) capsFlag = caps;
   
   var data = {};
   
   var top = 0.5;
   var bottom = -0.5;
   var radius = 0.07;
   
   var sideColor = [1.0, 0.0, 0.0, 1.0];
   var topColor = [0.0, 1.0, 0.0, 1.0];
   var bottomColor = [0.0, 0.0, 1.0, 1.0];
   
   
   var cylinderVertexCoordinates = [];
   var cylinderNormals = [];
   var cylinderVertexColors = [];
   var cylinderTextureCoordinates = [];
   
   // side of the cylinder
   for(var j=0; j<stacks; j++) {
     var stop = bottom + (j+1)*(top-bottom)/stacks;
     var sbottom = bottom + j*(top-bottom)/stacks;
     var topPoints = [];
     var bottomPoints = [];
     var topST = [];
     var bottomST = [];
     for(var i =0; i<slices; i++) {
       var theta = 2.0*i*Math.PI/slices;
       topPoints.push([radius*Math.sin(theta), stop, radius*Math.cos(theta), 1.0]);
       bottomPoints.push([radius*Math.sin(theta), sbottom, radius*Math.cos(theta), 1.0]);
     };
   
     topPoints.push([0.0, stop, radius, 1.0]);
     bottomPoints.push([0.0,  sbottom, radius, 1.0]);
   
   
     for(var i=0; i<slices; i++) {
       var a = topPoints[i];
       var d = topPoints[i+1];
       var b = bottomPoints[i];
       var c = bottomPoints[i+1];
       var u = [b[0]-a[0], b[1]-a[1], b[2]-a[2]];
       var v = [c[0]-b[0], c[1]-b[1], c[2]-b[2]];
   
       var normal = [
         u[1]*v[2] - u[2]*v[1],
         u[2]*v[0] - u[0]*v[2],
         u[0]*v[1] - u[1]*v[0]
       ];
   
       var mag = Math.sqrt(normal[0]*normal[0] + normal[1]*normal[1] + normal[2]*normal[2])
       normal = [normal[0]/mag, normal[1]/mag, normal[2]/mag];
       cylinderVertexCoordinates.push([a[0], a[1], a[2], 1.0]);
       cylinderVertexColors.push(sideColor);
       cylinderNormals.push([normal[0], normal[1], normal[2]]);
       cylinderTextureCoordinates.push([(i+1)/slices, j*(top-bottom)/stacks]);
   
       cylinderVertexCoordinates.push([b[0], b[1], b[2], 1.0]);
       cylinderVertexColors.push(sideColor);
       cylinderNormals.push([normal[0], normal[1], normal[2]]);
       cylinderTextureCoordinates.push([i/slices, (j-1)*(top-bottom)/stacks]);
   
       cylinderVertexCoordinates.push([c[0], c[1], c[2], 1.0]);
       cylinderVertexColors.push(sideColor);
       cylinderNormals.push([normal[0], normal[1], normal[2]]);
       cylinderTextureCoordinates.push([(i+1)/slices, (j-1)*(top-bottom)/stacks]);
   
       cylinderVertexCoordinates.push([a[0], a[1], a[2], 1.0]);
       cylinderVertexColors.push(sideColor);
       cylinderNormals.push([normal[0], normal[1], normal[2]]);
       cylinderTextureCoordinates.push([(i+1)/slices, j*(top-bottom)/stacks]);
   
       cylinderVertexCoordinates.push([c[0], c[1], c[2], 1.0]);
       cylinderVertexColors.push(sideColor);
       cylinderNormals.push([normal[0], normal[1], normal[2]]);
       cylinderTextureCoordinates.push([(i+1)/slices, (j-1)*(top-bottom)/stacks]);
   
       cylinderVertexCoordinates.push([d[0], d[1], d[2], 1.0]);
       cylinderVertexColors.push(sideColor);
       cylinderNormals.push([normal[0], normal[1], normal[2]]);
       cylinderTextureCoordinates.push([(i+1)/slices, j*(top-bottom)/stacks]);
     };
   };
   
     var topPoints = [];
     var bottomPoints = [];
     for(var i =0; i<slices; i++) {
       var theta = 2.0*i*Math.PI/slices;
       topPoints.push([radius*Math.sin(theta), top, radius*Math.cos(theta), 1.0]);
       bottomPoints.push([radius*Math.sin(theta), bottom, radius*Math.cos(theta), 1.0]);
     };
     topPoints.push([0.0, top, radius, 1.0]);
     bottomPoints.push([0.0,  bottom, radius, 1.0]);
   
   if(capsFlag) {
   
   //top face of the cylinder
   for(i=0; i<slices; i++) {
     normal = [0.0, 1.0, 0.0];
     var a = [0.0, top, 0.0, 1.0];
     var b = topPoints[i];
     var c = topPoints[i+1];
     cylinderVertexCoordinates.push([a[0], a[1], a[2], 1.0]);
     cylinderVertexColors.push(topColor);
     cylinderNormals.push(normal);
     cylinderTextureCoordinates.push([0, 1]);
   
     cylinderVertexCoordinates.push([b[0], b[1], b[2], 1.0]);
     cylinderVertexColors.push(topColor);
     cylinderNormals.push(normal);
     cylinderTextureCoordinates.push([0, 1]);
   
     cylinderVertexCoordinates.push([c[0], c[1], c[2], 1.0]);
     cylinderVertexColors.push(topColor);
     cylinderNormals.push(normal);
     cylinderTextureCoordinates.push([0, 1]);
   };
   
   //bottom face of the cylinder
   for(i=0; i<slices; i++) {
     normal = [0.0, -1.0, 0.0];
     var a = [0.0, bottom, 0.0, 1.0];
     var b = bottomPoints[i];
     var c = bottomPoints[i+1];
     cylinderVertexCoordinates.push([a[0], a[1], a[2], 1.0]);
     cylinderVertexColors.push(bottomColor);
     cylinderNormals.push(normal);
     cylinderTextureCoordinates.push([0, 1]);
   
     cylinderVertexCoordinates.push([b[0], b[1], b[2], 1.0]);
     cylinderVertexColors.push(bottomColor);
     cylinderNormals.push(normal);
     cylinderTextureCoordinates.push([0, 1]);
   
     cylinderVertexCoordinates.push([c[0], c[1], c[2], 1.0]);
     cylinderVertexColors.push(bottomColor);
     cylinderNormals.push(normal);
     cylinderTextureCoordinates.push([0, 1]);
   };
   
   };
   function translate(x, y, z){
      for(var i=0; i<cylinderVertexCoordinates.length; i++) {
        cylinderVertexCoordinates[i][0] += x;
        cylinderVertexCoordinates[i][1] += y;
        cylinderVertexCoordinates[i][2] += z;
      };
   }
   
   function scale(sx, sy, sz){
       for(var i=0; i<cylinderVertexCoordinates.length; i++) {
           cylinderVertexCoordinates[i][0] *= sx;
           cylinderVertexCoordinates[i][1] *= sy;
           cylinderVertexCoordinates[i][2] *= sz;
           cylinderNormals[i][0] /= sx;
           cylinderNormals[i][1] /= sy;
           cylinderNormals[i][2] /= sz;
       };
   }
   
   function radians( degrees ) {
       return degrees * Math.PI / 180.0;
   }
   
   function rotate( angle, axis) {
   
       var d = Math.sqrt(axis[0]*axis[0] + axis[1]*axis[1] + axis[2]*axis[2]);
   
       var x = axis[0]/d;
       var y = axis[1]/d;
       var z = axis[2]/d;
   
       var c = Math.cos( radians(angle) );
       var omc = 1.0 - c;
       var s = Math.sin( radians(angle) );
   
       var mat = [
           [ x*x*omc + c,   x*y*omc - z*s, x*z*omc + y*s ],
           [ x*y*omc + z*s, y*y*omc + c,   y*z*omc - x*s ],
           [ x*z*omc - y*s, y*z*omc + x*s, z*z*omc + c ]
       ];
   
       for(var i=0; i<cylinderVertexCoordinates.length; i++) {
             var u = [0, 0, 0];
             var v = [0, 0, 0];
             for( var j =0; j<3; j++)
              for( var k =0 ; k<3; k++) {
                 u[j] += mat[j][k]*cylinderVertexCoordinates[i][k];
                 v[j] += mat[j][k]*cylinderNormals[i][k];
               };
              for( var j =0; j<3; j++) {
                cylinderVertexCoordinates[i][j] = u[j];
                cylinderNormals[i][j] = v[j];
              };
       };
   }
   
   data.TriangleVertices = cylinderVertexCoordinates;
   data.TriangleNormals = cylinderNormals;
   data.TriangleVertexColors = cylinderVertexColors;
   data.TextureCoordinates = cylinderTextureCoordinates;
   data.rotate = rotate;
   data.translate = translate;
   data.scale = scale;
   return data;   
}
//---------------------------------------------------------------------------------------------------------------------

var positionsArray = [];
var normalsArray = [];
var textureCoordsArray = [
    vec2(0, 0),
    vec2(0, 1),
    vec2(1, 1),
    vec2(1, 0)
];


var vertices = [
    vec4(-0.31, 0.35, 0.4, 1.0),
    vec4(-0.11, 0.42, 0.4, 1.0),
    vec4(0.28, 0.42, 0.4, 1.0),
    vec4(0.1, 0.02, 0.4, 1.0),
    vec4(-0.07, -0.08, 0.4, 1.0),
    vec4(-0.21, -0.08, 0.4, 1.0),
    vec4(-0.41, 0.12, 0.4, 1.0),
    vec4(-0.46 ,0.5, 0.2, 1.0),
    vec4(-0.15 ,0.62, 0.2, 1.0),
    vec4(0.59, 0.62, 0.2, 1.0),
    vec4(0.26, -0.12, 0.2, 1.0),
    vec4(-0.02, -0.28, 0.2, 1.0),
    vec4(-0.29, -0.28, 0.2, 1.0),
    vec4(-0.65, 0.08, 0.2, 1.0),

    vec4(-0.65, 0.08, 0, 1.0),
    vec4(-0.46, 0.5, 0, 1.0),
    vec4(-0.15, 0.62, 0, 1.0),
    vec4(0.59, 0.62, 0, 1.0),
    vec4(0.26, -0.12, 0, 1.0),
    vec4(-0.02, -0.28, 0, 1.0),
    vec4(-0.29 ,-0.28, 0, 1.0),
    vec4(-0.24, 0.23, -0.3, 1.0),
    vec4(-0.14, 0.46, -0.3, 1.0),
    vec4(0.05, 0.54, -0.3, 1.0),
    vec4(0.45, 0.54, -0.3, 1.0),
    vec4(0.27, 0.14, -0.3, 1.0),
    vec4(0.09, 0.04, -0.3, 1.0),
    vec4(-0.04, 0.04, -0.3, 1.0),

];

function barycenterCoords(){
var x = 0;
var y = 0;
var z = 0;

for(var i = 0; i<vertices.length; i++){
   x += vertices[i][0];
   y += vertices[i][1];
   z += vertices[i][2];
}

x = x/27;
y = y/27;
z = z/27;

return vec4(x, y, z, 1.0);

}
//at is initialized such as the camera looks directly the objectinits new position around the barycenter
var at = vec3(barycenterCoords()[0],barycenterCoords()[1],barycenterCoords()[2]);
var up = vec3(0.0, 1.0, 0.0);


var ambientProduct;
var diffuseProduct;
var specularProduct;

var ambientProduct0;
var diffuseProduct0;
var specularProduct0;

var lightAmbient = vec4(0.2, 0.2, 0.2, 1.0);
var lightDiffuse = vec4(1.0, 1.0, 1.0, 1.0);
var lightSpecular = vec4(1.0, 1.0, 1.0, 1.0);

var lightAmbient0 = vec4(0.2, 0.2, 0.2, 1.0);
var lightDiffuse0 = vec4(1.0, 1.0, 1.0, 1.0);
var lightSpecular0 = vec4(1.0, 1.0, 1.0, 1.0);

//lights positioning
var lightPosition = vec4(1.0, 1.0, 1.0, 0.0);
var lightPosition2 = vec4(0, 1.7, 0, 0.0);
var lightPosition3 = vec4(-1, 1.7, 0, 0.0);
var lightPosition4 = vec4(-0.5, 1.7, 0, 0.0);

//materialof the polygon
var materialAmbient = vec4(0.0215, 0.1745, 0.0215, 0.55);
var materialDiffuse = vec4(0.07568, 0.61424, 0.07568, 0.55);
var materialSpecular = vec4(0.633, 0.727811, 0.633, 0.55);
var materialShininess = 60;

var modelViewMatrix, projectionMatrix;
var modelViewMatrixLoc, projectionMatrixLoc;

var viewerPos;
var program;

var xAxis = 0;
var yAxis = 1;
var zAxis = 2;

var axis = 0;

var pos = true;

var theta = vec3(0, 0, 0);

var thetaLoc;
var theta2Loc;

var flag = false;
var invert = false;
var texture_flag = true;
var switcher = true;
var switcher0 = true;

var texCoord = [];

var normal = vec4(0.0, 1.0, 0.0, 0.0);
var tangent = vec3(1.0, 0.0, 0.0);

function configureTexture( image ) {
   var texture = gl.createTexture();
   gl.activeTexture(gl.TEXTURE0);
   gl.bindTexture(gl.TEXTURE_2D, texture);
   gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, texSize, texSize, 0, gl.RGB, gl.UNSIGNED_BYTE, image);
   gl.generateMipmap(gl.TEXTURE_2D);

}

init();


function quad(a, b, c, d) {

     var t1 = subtract(vertices[b], vertices[a]);
     var t2 = subtract(vertices[c], vertices[b]);
     var normal = cross(t1, t2);
     normal = vec3(normal);

     positionsArray.push(vertices[a]);
     normalsArray.push(normal);
     texCoord.push(textureCoordsArray[0]);

     positionsArray.push(vertices[b]);
     normalsArray.push(normal);
     texCoord.push(textureCoordsArray[1]);

     positionsArray.push(vertices[c]);
     normalsArray.push(normal);
     texCoord.push(textureCoordsArray[2]);

     positionsArray.push(vertices[a]);
     normalsArray.push(normal);
     texCoord.push(textureCoordsArray[0]);

     positionsArray.push(vertices[c]);
     normalsArray.push(normal);
     texCoord.push(textureCoordsArray[2]);

     positionsArray.push(vertices[d]);
     normalsArray.push(normal);
     texCoord.push(textureCoordsArray[3]);
}


function colorCube()
{
    //top surface (z directed to the user)
    quad(5, 4, 0, 6);
    quad(4, 3, 1, 0);
    quad(3, 2, 1, 3);
    quad(0, 1, 8, 7);
    quad(1, 2, 9, 8);
    quad(10, 9, 2, 3);
    quad(11, 10, 3, 4);
    quad(12, 11, 4, 5);
    quad(13, 12, 5, 6);
    quad(7, 13, 6, 0);

    //bottom surface (z directed to the screen)
    quad(26, 27, 21, 22);
    quad(25, 26, 22, 23);
    quad(24, 25, 23, 24);
    
    quad(19, 26, 25, 18);
    quad(20, 27, 26, 19);
    quad(14, 21, 27, 20);
    quad(15, 22, 21, 14);
    quad(16, 23, 22, 15);
    quad(17, 24, 23, 16);
    quad(18, 25, 24, 17);

    //side faces
    quad(18, 17, 9, 10);
    quad(19, 18, 10, 11);
    quad(20, 19, 11, 12);
    quad(14, 20, 12, 13);
    quad(15, 14, 13, 7);
    quad(16, 15, 7, 8);
    quad(17, 16, 8, 9);


}

function init() {
    canvas = document.getElementById("gl-canvas");

    gl = canvas.getContext('webgl2');
    if (!gl) alert( "WebGL 2.0 isn't available");

    aspect =  canvas.width/canvas.height;

    gl.viewport(0, 0, canvas.width, canvas.height);
    gl.clearColor(1.0, 1.0, 1.0, 1.0);

    gl.enable(gl.DEPTH_TEST);

    program = initShaders(gl, "vertex-shader", "fragment-shader");
    gl.useProgram(program);
   

    colorCube();

   //---------------------CYLINDER----------------------------
   var myCylinder = cylinder(72, 3, true);
   myCylinder.scale(0.3, 2, 0.3);
   myCylinder.rotate(90, [ 0, 0, 1]);
   myCylinder.translate(0.0, 1.7, 0);
   
   // put object data in arrays that will be sent to shaders
   pointsCYL = myCylinder.TriangleVertices;
   normalsCYL = myCylinder.TriangleNormals;
   texCoordCYL = myCylinder.TextureCoordinates;
   // object sizes (number of vertices)
   positionsArray = positionsArray.concat(pointsCYL);
   normalsArray = normalsArray.concat(normalsCYL);

   ncylinder = myCylinder.TriangleVertices.length;
   //--------------------------------------------------------

    var nBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, nBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, flatten(normalsArray), gl.STATIC_DRAW);

    var normalLoc = gl.getAttribLocation(program, "aNormal");
    gl.vertexAttribPointer(normalLoc, 3, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(normalLoc);

    var vBuffer = gl.createBuffer();
   gl.bindBuffer(gl.ARRAY_BUFFER, vBuffer);
   gl.bufferData(gl.ARRAY_BUFFER, flatten(positionsArray), gl.STATIC_DRAW);


   var positionLoc = gl.getAttribLocation(program, "aPosition");
    gl.vertexAttribPointer(positionLoc, 4, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(positionLoc);
 

    var tBuffer = gl.createBuffer();
    gl.bindBuffer( gl.ARRAY_BUFFER, tBuffer);
    gl.bufferData( gl.ARRAY_BUFFER, flatten(texCoord), gl.STATIC_DRAW);

    var texCoordLoc = gl.getAttribLocation( program, "aTexCoord");
    gl.vertexAttribPointer( texCoordLoc, 2, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(texCoordLoc);

    configureTexture(normals);

    modelViewMatrixLoc = gl.getUniformLocation(program, "uModelViewMatrix");
    projectionMatrixLoc = gl.getUniformLocation(program, "uProjectionMatrix");
    
    thetaLoc = gl.getUniformLocation(program, "theta");
    theta2Loc = gl.getUniformLocation(program, "theta2");

    nMatrixLoc = gl.getUniformLocation(program, "uNormalMatrix");

    viewerPos = vec3(0.0, 0.0, -2.0);

    //projectionMatrix = perspective(-1, 1, -1, 1, -100, 100);

    ambientProduct = mult(lightAmbient, materialAmbient);
    diffuseProduct = mult(lightDiffuse, materialDiffuse);
    specularProduct = mult(lightSpecular, materialSpecular);

    document.getElementById("ButtonX").onclick = function(){axis = xAxis;};
    document.getElementById("ButtonY").onclick = function(){axis = yAxis;};
    document.getElementById("ButtonZ").onclick = function(){axis = zAxis;};
    document.getElementById("Invert").onclick = function(){pos = !pos;};
    
    document.getElementById("Start").onclick = function(){flag = true;};
    document.getElementById("Stop").onclick = function(){flag = false;};

    //eye translation
    document.getElementById("LeftEye").onclick = function(){
      theta2 += dr;
     };
   document.getElementById("RightEye").onclick = function(){
      theta2 -= dr;
     };
   //radius of the eye
    document.getElementById("FarZ").onclick = function(){
       radius += dr;
      };
    document.getElementById("NearZ").onclick = function(){
       radius -= dr;
      };
      //phi eye
   document.getElementById("UpEye").onclick = function(){
      phi += dr;
      };
   document.getElementById("DownEye").onclick = function(){
      phi -= dr;
     };
   document.getElementById("FarPull").onclick = function(){
      far -= 0.1;
   }
   document.getElementById("NearPull").onclick = function(){
      near -= 0.05; //increments the visual
   }
   document.getElementById("FarPush").onclick = function(){
      far += 0.1;
   }
   document.getElementById("NearPush").onclick = function(){
      near += 0.05; //decreases the visual
   }
   
    document.getElementById("FOVup").onclick = function(){fovy += 2;};
    document.getElementById("FOVdown").onclick = function(){fovy -= 2;};

    //changes the shading technique to use
    document.getElementById("Vertex").onclick = function(){
       invert = false;
       gl.uniform1f(gl.getUniformLocation(program,"invert"), invert);
      };
    document.getElementById("Fragment").onclick = function(){
       invert = true;
       gl.uniform1f(gl.getUniformLocation(program,"invert"), invert);};

    document.getElementById("TexOn").onclick = function(){
       texture_flag = true;
       gl.uniform1f(gl.getUniformLocation(program,"texture_flag"), texture_flag);};
    document.getElementById("TexOff").onclick = function(){
       texture_flag = false;
       gl.uniform1f(gl.getUniformLocation(program,"texture_flag"), texture_flag);};
    
    //neon lights
    document.getElementById("LightOnNeon").onclick = function(){switcher = true};
    document.getElementById("LightOffNeon").onclick = function(){switcher = false};
    //classic spotlight
    document.getElementById("LightOff").onclick = function(){switcher0 = false};
    document.getElementById("LightOn").onclick = function(){switcher0 = true};

    //aspect ratio
    document.getElementById("AspectLow").onclick = function(){aspect -= dr;};
    document.getElementById("AspectUp").onclick = function(){aspect += dr;};

    gl.uniform4fv(gl.getUniformLocation(program, "uAmbientProduct"),
       ambientProduct);
    gl.uniform4fv(gl.getUniformLocation(program, "uDiffuseProduct"),
       diffuseProduct );
    gl.uniform4fv(gl.getUniformLocation(program, "uSpecularProduct"),
       specularProduct );
    gl.uniform4fv(gl.getUniformLocation(program, "uLightPosition"),
       lightPosition );

    gl.uniform4fv(gl.getUniformLocation(program, "uLightPosition2"),lightPosition2 );
    gl.uniform4fv(gl.getUniformLocation(program, "uLightPosition3"),lightPosition3 );
    gl.uniform4fv(gl.getUniformLocation(program, "uLightPosition4"),lightPosition4 );

    gl.uniform3fv( gl.getUniformLocation(program, "uObjTangent"), tangent);
    gl.uniform4fv( gl.getUniformLocation(program, "uNormal"), normal);

    gl.uniform1f(gl.getUniformLocation(program,
       "uShininess"), materialShininess);

    //gl.uniformMatrix4fv( gl.getUniformLocation(program, "uProjectionMatrix"),
       //false, flatten(projectionMatrix));
    render();
}


function render(){

    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
    
    var barycenter = barycenterCoords();
    eye = vec3(radius*Math.sin(theta2)*Math.cos(phi),radius*Math.sin(theta2)*Math.sin(phi), radius*Math.cos(theta2));
   
    var modelViewCYL = mat4();
    modelViewCYL = mult(modelViewCYL, lookAt(eye, at, up));
    gl.uniformMatrix4fv(gl.getUniformLocation(program, "uModelViewMatrix"), false, flatten(modelViewCYL));
    gl.drawArrays(gl.TRIANGLES, numPositions, ncylinder);

    modelViewMatrix = mat4();
    modelViewMatrix =translate(barycenter[0], barycenter[1], barycenter[2]);
    modelViewMatrix = mult(modelViewMatrix, lookAt(eye, at, up));
    projectionMatrix = perspective(fovy, aspect, near, far);
    
    nMatrix = normalMatrix(modelViewMatrix, true); 

    if(flag && pos) theta[axis] += 2.0;
    if(flag && !pos) theta[axis] -= 2.0;
    
    modelViewMatrix = mult(modelViewMatrix, rotate(theta[xAxis], vec3(1, 0, 0)));
    modelViewMatrix = mult(modelViewMatrix, rotate(theta[yAxis], vec3(0, 1, 0)));
    modelViewMatrix = mult(modelViewMatrix, rotate(theta[zAxis], vec3(0, 0, 1)));

    if(!switcher){
      lightAmbient = vec4(0, 0, 0, 1);
      lightDiffuse = vec4(0, 0, 0, 1);
      lightSpecular = vec4(0, 0, 0, 1);
    }
    else{
      lightAmbient = vec4(0.2, 0.2, 0.2, 1.0);
      lightDiffuse = vec4(1.0, 1.0, 1.0, 1.0);
      lightSpecular = vec4(1.0, 1.0, 1.0, 1.0);
    }

    if(!switcher0){
      lightAmbient0 = vec4(0, 0, 0, 1.0);
      lightDiffuse0 = vec4(0, 0, 0, 1.0);
      lightSpecular0 = vec4(0, 0, 0, 1.0);
    } else {
      lightAmbient0 = vec4(0.2, 0.2, 0.2, 1.0);
      lightDiffuse0 = vec4(1.0, 1.0, 1.0, 1.0);
      lightSpecular0 = vec4(1.0, 1.0, 1.0, 1.0);

    }

    ambientProduct = mult(lightAmbient, materialAmbient);
    diffuseProduct = mult(lightDiffuse, materialDiffuse);
    specularProduct = mult(lightSpecular, materialSpecular);

    ambientProduct0 = mult(lightAmbient0, materialAmbient);
    diffuseProduct0 = mult(lightDiffuse0, materialDiffuse);
    specularProduct0 = mult(lightSpecular0, materialSpecular);

    //neon light
    gl.uniform4fv(gl.getUniformLocation(program, "uAmbientProduct"),flatten(ambientProduct));
    gl.uniform4fv(gl.getUniformLocation(program, "uDiffuseProduct"),flatten(diffuseProduct) );
    gl.uniform4fv(gl.getUniformLocation(program, "uSpecularProduct"),flatten(specularProduct) );

    //spotlight
    gl.uniform4fv(gl.getUniformLocation(program, "uAmbientProduct0"),flatten(ambientProduct0));
    gl.uniform4fv(gl.getUniformLocation(program, "uDiffuseProduct0"),flatten(diffuseProduct0));
    gl.uniform4fv(gl.getUniformLocation(program, "uSpecularProduct0"),flatten(specularProduct0));

    gl.uniformMatrix4fv(modelViewMatrixLoc, false, flatten(modelViewMatrix));
    gl.uniformMatrix4fv(projectionMatrixLoc, false, flatten(projectionMatrix));
    gl.uniformMatrix4fv(gl.getUniformLocation(program, "uProjectionMatrix"),false, flatten(projectionMatrix));
    gl.uniformMatrix3fv(nMatrixLoc, false, flatten(nMatrix));
    gl.uniformMatrix4fv(gl.getUniformLocation(program,"uModelViewMatrix"), false, flatten(modelViewMatrix));

    gl.drawArrays(gl.TRIANGLES, 0, numPositions);
    
    requestAnimationFrame(render);
}

}

shadedPoly();
